<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>雨人的博客</title>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <link>http://localhost:4000/</link>
    <description>A website with blog posts and pages</description>
    <pubDate>Sat, 03 Feb 2018 14:07:49 +0800</pubDate>
    
      <item>
        <title>MAVEN工作原理</title>
        <link>/2018/02/03/Maven%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html</link>
        <guid isPermaLink="true">/2018/02/03/Maven%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html</guid>
        <description>&lt;h2 id=&quot;maven插件的生命周期&quot;&gt;maven插件的生命周期&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://oqk2bkk90.bkt.clouddn.com/14834267005578.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;maven指令与生命周期阶段的关系&quot;&gt;maven指令与生命周期阶段的关系&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://oqk2bkk90.bkt.clouddn.com/14830016483295.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mvn compile  //让当前项目经历生命周期中的1--&amp;gt;7 阶段 ：完成编译主源代码编译
mvn package  //让当前项目经历生命周期中的1--&amp;gt;17阶段 ：完成打包
mvn install  //让当前项目经历生命周期中的1--&amp;gt;22阶段 ：完成包安装到本地仓库
mvn deploy   //让当前生命经历生命周期中的1--&amp;gt;23阶段 ：完成包部署到中心库中 ## 日常关注的阶段

1 应该将resource资源文件准备好，放到指定的target目录下----process-resources 阶段；
2 将java源文件编译成.class文件，然后将class 文件放置到对应的target目录下----compile阶段；
3 将test类型的resource移动到指定的 target目录下------process-test-resource阶段；
4 将test类型的java 源文件编译成class文件，然后放置到指定的target目录下------test-compile阶段；
5 运行test测试用例-------test阶段；
6 将compile阶段编译的class文件和resource资源打包成jar包或war包--------package阶段；
7 将生成的包安装到本地仓库中------install阶段
8 将生成的包部署到远程仓库中-----deploy阶段
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;maven默认的生命周期和插件绑定&quot;&gt;MAVEN默认的生命周期和插件绑定&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://oqk2bkk90.bkt.clouddn.com/14830018675188.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;jar和war默认的生命周期&quot;&gt;JAR和WAR默认的生命周期&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://oqk2bkk90.bkt.clouddn.com/14830019553942.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;maven插件原理&quot;&gt;MAVEN插件原理&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://oqk2bkk90.bkt.clouddn.com/14830020691173.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://oqk2bkk90.bkt.clouddn.com/14830021059886.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;使用mvn的help插件&quot;&gt;使用mvn的help插件&lt;/h2&gt;
&lt;h3 id=&quot;查看maven-surefire-plugin插件test目标的详细介绍&quot;&gt;查看maven-surefire-plugin插件test目标的详细介绍&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mvn help:describe -Dplugin=compiler
mvn help:describe -Dplugin=compiler -Ddetail=true
mvn help:describe -Dplugin=compiler -Dgoal=compile
mvn surefire:help -Ddetail=true -Dgoal=test
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;help插件的goals&quot;&gt;help插件的goals&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;help:active-profiles
help:all-profiles
help:describe
help:effective-pom
help:effective-settings
help:evaluate
help:expressions
help:help
help:system
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
        <pubDate>Sat, 03 Feb 2018 00:00:00 +0800</pubDate>
      </item>
    
      <item>
        <title>使用git rebase 合并提交</title>
        <link>/2017/12/12/Git-Rebase%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8.html</link>
        <guid isPermaLink="true">/2017/12/12/Git-Rebase%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8.html</guid>
        <description>&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;先看一个github贡献代码的操作流程：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;fork一个项目，在自己的repo下面产生一个fork过来的项目副本&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git clone&lt;/code&gt; 到本地做自己的修改，&lt;/li&gt;
  &lt;li&gt;将本地的修改 commit到仓库，push到github&lt;/li&gt;
  &lt;li&gt;发起一个&lt;code class=&quot;highlighter-rouge&quot;&gt;pull request&lt;/code&gt;请求项目的owner来进行合并&lt;/li&gt;
  &lt;li&gt;owner合并代码到项目，完成代码的贡献&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;当修改历史比较多的时候，也就是说，提交了n次的commit操作，这个时候，git 的提交历史会很不优雅，可能这些提交都是针对一个功能点做的改动。合并到owner的仓库去，也会污染原始项目的提交历史。这时可以借助rebase来进行提交历史的合并，来改变历史，使得代码提交历史更加优雅。&lt;/p&gt;

&lt;h2 id=&quot;git-rebase简介&quot;&gt;git rebase简介&lt;/h2&gt;
&lt;p&gt;简单来说rebase就是把某个分支上的一部分commit嫁接到另一个commit后面，而在这个过程中这些commit的base（基）变了，所以这个操作叫做『变基』。&lt;/p&gt;

&lt;p&gt;git rebase 用法如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;usage: git rebase [-i] [options] [--exec &amp;lt;cmd&amp;gt;] [--onto &amp;lt;newbase&amp;gt;] [&amp;lt;upstream&amp;gt;] [&amp;lt;branch&amp;gt;]
   or: git rebase [-i] [options] [--exec &amp;lt;cmd&amp;gt;] [--onto &amp;lt;newbase&amp;gt;] --root [&amp;lt;branch&amp;gt;]
   or: git-rebase --continue | --abort | --skip | --edit-todo

Available options are
    -v, --verbose         display a diffstat of what changed upstream
    -q, --quiet           be quiet. implies --no-stat
    --autostash           automatically stash/stash pop before and after
    --fork-point          use 'merge-base --fork-point' to refine upstream
    --onto ...            rebase onto given branch instead of upstream
    -p, --preserve-merges
                          try to recreate merges instead of ignoring them
    -s, --strategy ...    use the given merge strategy
    --no-ff               cherry-pick all commits, even if unchanged
    -m, --merge           use merging strategies to rebase
    -i, --interactive     let the user edit the list of commits to rebase
    -x, --exec ...        add exec lines after each commit of the editable list
    -k, --keep-empty	     preserve empty commits during rebase
    -f, --force-rebase    force rebase even if branch is up to date
    -X, --strategy-option ...
                          pass the argument through to the merge strategy
    --stat                display a diffstat of what changed upstream
    -n, --no-stat         do not show diffstat of what changed upstream
    --verify              allow pre-rebase hook to run
    --rerere-autoupdate   allow rerere to update index with resolved conflicts
    --root                rebase all reachable commits up to the root(s)
    --autosquash         move commits that begin with squash
                          move commits that begin with squash!/fixup! under -i
    --committer-date-is-author-date
                          passed to 'git am'
    --ignore-date         passed to 'git am'
    --whitespace ...      passed to 'git apply'
    --ignore-whitespace   passed to 'git apply'
    -C ...                passed to 'git apply'
    -S, --gpg-sign[=...]  GPG-sign commits

Actions:
    --continue            continue
    --abort               abort and check out the original branch
    --skip                skip current patch and continue
    --edit-todo           edit the todo list during an interactive rebase
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;修改历史 &lt;code class=&quot;highlighter-rouge&quot;&gt;git rebase -i&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pick = 要這條 commit ，什麼都不改
reword = 要這條 commit ，但要改 commit message
edit = 要這條 commit，但要改 commit 的內容
squash = 要這條 commit，但要跟前面那條合併，並保留這條的 messages
fixup = squash + 只使用前面那條 commit 的 message ，捨棄這條 message
exec = 執行一條指令（但我沒用過）
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;使用&quot;&gt;使用&lt;/h2&gt;

&lt;p&gt;比如我们有如下的提交历史，当前的分支是topic：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;     A---B---C topic(HEAD)
    /
D---E---F---G master
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们执行了如下任何一个命令之后：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git rebase master
$ git rebase master topic
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;提交历史将会变成如下这样：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;              A'--B'--C' topic(HEAD)
             /
D---E---F---G master
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以看出git把A—B—C这段commit嫁接到了G之后，不过虽然这些新commit的内容是一样的，但是hash值是不同的（A’–B’–C’），原因将在后面解释。&lt;/p&gt;

&lt;p&gt;命令完整的形式如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git rebase &amp;lt;upstream&amp;gt; &amp;lt;branch&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中&lt;upstream&gt;是新的base，如果你提供&lt;branch&gt;，那么首先会checkout到这个&lt;branch&gt;，然后再进行rebase操作。所以以下两种方式&lt;/branch&gt;&lt;/branch&gt;&lt;/upstream&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git rebase master topic
$ git rebase master
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;的区别是第一种形式会首先checkout到topic分支，然后再执行rebase的操作。&lt;/p&gt;

&lt;p&gt;那么rebase都做了什么事情呢？&lt;/p&gt;

&lt;p&gt;首先，git会对topic分支和&lt;upstream&gt;做一个差集，把不同的commit找出来，类似于执行git log &lt;upstream&gt;..HEAD，对于以上例子来说结果就是A---B---C，然后把这些commit存在一个临时的地方。&lt;/upstream&gt;&lt;/upstream&gt;&lt;/p&gt;

&lt;p&gt;其次，git会把当前分支reset到&lt;upstream&gt;上，类似于执行git reset --hard &lt;upstream&gt;命令。对于以上例子来说就是reset到master。&lt;/upstream&gt;&lt;/upstream&gt;&lt;/p&gt;

&lt;p&gt;最后，git把第一步中暂存的commit，按照顺序一个一个地应用到分支上，相当于一个一个重复提交，这就是为什么rebase之后commit的hash值变了。&lt;/p&gt;

&lt;p&gt;如果中的一个commit进行了某项修改，而当前分支中也存在一个commit，这两个commit的修改的内容一样，那么当前分支中的commit将会被忽略。比如以下的&lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;A'&lt;/code&gt;就是这样两个commit。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      A---B---C topic
     /
D---E---A'---F master 执行完git rebase master之后，结果如下：

               B'---C' topic
              /
D---E---A'---F master
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果你想更灵活的进行commit嫁接，那么你需要rebase –onto，命令格式如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git rebase --onto &amp;lt;newbase&amp;gt; &amp;lt;upstream&amp;gt; &amp;lt;branch&amp;gt; 假设你有如下的branch tree：

o---o---o---o---o  master
         \
          o---o---o---o---o  next
                           \
                            o---o---o  topic 你想要得到如下的branch tree：

o---o---o---o---o  master
        |            \
        |             o'--o'--o'  topic
         \
          o---o---o---o---o  next 那我们需要如下操作：

$ git rebase --onto master next topic 这个操作会把从next开始的commit嫁接到master上。如果你提供&amp;lt;branch&amp;gt;，那么首先会checkout到这个&amp;lt;branch&amp;gt;，然后再进行rebase操作。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们再看一个例子，比如我们有如下的branch tree：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;E---F---G---H---I---J  topicA 我们想要删除F---G这两个commit，那么通过rebase --onto就可以实现：

$ git rebase --onto topicA~5 topicA~3 topicA 执行结果是：

E---H'---I'---J'  topicA 同样，rebase也会产生冲突，当解决完冲突之后你可以继续rebase的进程：

$ git rebase --continue 或者取消此次rebase：

$ git rebase --abort 关于commit修改、顺序调整、合并等操作可以通过rebase -i来完成

$ git rebase -i &amp;lt;upstream&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.yorkxin.org/2011/07/29/git-rebase&quot;&gt;https://blog.yorkxin.org/2011/07/29/git-rebase&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.tuicool.com/articles/q2eURn&quot;&gt;http://www.tuicool.com/articles/q2eURn&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/alps1992/article/details/38548107&quot;&gt;http://blog.csdn.net/alps1992/article/details/38548107&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Tue, 12 Dec 2017 00:00:00 +0800</pubDate>
      </item>
    
      <item>
        <title>Linux配置端口转发</title>
        <link>/2017/10/16/Linux%E4%B8%8B%E9%85%8D%E7%BD%AE%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91.html</link>
        <guid isPermaLink="true">/2017/10/16/Linux%E4%B8%8B%E9%85%8D%E7%BD%AE%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91.html</guid>
        <description>&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt; ssh -C -f -N -g root@192.168.0.1 -L 20022:192.168.0.2:20022&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;应用场景举例：
实现下面两个Shell&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ mysql -h10.13.34.119 -P3306 -uroot -p123456
$ mysql -h10.13.34.120 -P3307 -uroot -p123456
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;都是同样访问 10.13.34.119:3306 这个数据库服务器
这时候我们就需要将 10.13.34.120:3307 映射到 10.13.34.119:3306&lt;/p&gt;

&lt;p&gt;##第一种：利用iptable&lt;/p&gt;

&lt;p&gt;iptables，大家都知道，网络防火墙，就是用于实现Linux下访问控制的东东
先打开IP转发：&lt;/p&gt;

&lt;p&gt;echo 1 &amp;gt; /proc/sys/net/ipv4/ip_forward
添加NAT规则，并重启iptables：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;service iptables stop
iptables -t nat -A PREROUTING --dst 10.13.34.119 -p tcp --dport 3306 -j DNAT --to-destination 10.13.34.120:3307
iptables -t nat -A POSTROUTING --dst 10.13.34.120 -p tcp --dport 3307 -j SNAT --to-source 10.13.34.119
service iptables save
service iptables start

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;##第二种：使用SSH协议转发&lt;/p&gt;

&lt;p&gt;ssh的三个强大的端口转发命令：&lt;/p&gt;

&lt;p&gt;转发到远端：ssh -C -f -N -g -L 本地端口:目标IP:目标端口 用户名@目标IP
转发到本地：ssh -C -f -N -g –R 本地端口:目标IP:目标端口 用户名@目标IP
ssh -C -f -N -g -D listen_port user@Tunnel_Host
这里我们使用第一种，只需在 10.13.34.120 这个机器执行以下命令：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$ ssh -C -f -N -g root@10.121.34.119 -L 3307:10.121.34.119:3306&lt;/code&gt;
-C ：压缩数据传输。
-f ：后台认证用户/密码，通常和 -N 连用，不用登录到远程主机。
-N ：不执行脚本或命令，通常与 -f 连用。
-g ：在-L/-R/-D参数中，允许远程主机连接到建立的转发的端口，如果不加这个参数，只允许本地主机建立连接。
-L ：转发规则，本地端口:目标IP:目标端口&lt;/p&gt;

&lt;p&gt;如此，当你使用&lt;/p&gt;

&lt;p&gt;mysql -h10.13.34.120 -P3307 -uroot -p123456
时，就会自动转发到 10.121.34.119:3306&lt;/p&gt;

</description>
        <pubDate>Mon, 16 Oct 2017 00:00:00 +0800</pubDate>
      </item>
    
      <item>
        <title>DevOps</title>
        <link>/2017/06/28/%E5%85%B3%E4%BA%8EDevOps.html</link>
        <guid isPermaLink="true">/2017/06/28/%E5%85%B3%E4%BA%8EDevOps.html</guid>
        <description>&lt;h2 id=&quot;devops是什么&quot;&gt;DevOps是什么&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;DevOps是软件开发、运维和质量保证三个部门之间的沟通、协作和集成所采用的流程、方法和体系的一个集合。它是人们为了及时生产软件产品或服务，以满足某个业务目标，对开发与运维之间相互依存关系的一种新的理解。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;http://oqk2bkk90.bkt.clouddn.com/14982072771613.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;devops概念&quot;&gt;DevOps概念&lt;/h3&gt;

&lt;p&gt;DevOps是一种融合了一系列基本原则和实践的方法论（并从这些实践中派生出了各种工具），意在帮助这些人员向着一个统一的共同目的努力：&lt;strong&gt;尽可能为公司提供更多价值&lt;/strong&gt;。令人惊奇的是，这个问题还有一个非常简单的“银弹”：&lt;strong&gt;让生产端变得敏捷起来！&lt;/strong&gt; 而这恰恰正是DevOps所要达成的&lt;strong&gt;唯一目标&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在进一步讨论这一点之前，首先需要谈谈其他几件事&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;管理信条&lt;/li&gt;
  &lt;li&gt;一个典型的IT组织&lt;/li&gt;
  &lt;li&gt;时间都去哪了&lt;/li&gt;
  &lt;li&gt;基础架构自动化&lt;/li&gt;
  &lt;li&gt;银弹&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;管理信条&quot;&gt;管理信条&lt;/h3&gt;

&lt;p&gt;IT管理这场战争的原动力到底是什么？换句话说，在软件开发项目中，管理工作首要的，以及最重要的目的是什么？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;当然是要加快上市时间（TTM）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;上市时间（即TTM）是指一件产品从最初的构思到最终可供用户使用或购买这一过程所需要的时间。TTM通常也会被叫做前置时间（Lead Time）。&lt;/p&gt;

&lt;p&gt;第一个问题在于，（很多人认为）在开发过程中TTM和产品质量是两个对立的属性。改善质量（进而提高稳定性）是负责运行软件的运维人员的目的，而负责构建软件的开发者的目的在于降低前置时间（进而提高TTM.&lt;/p&gt;

&lt;h3 id=&quot;一个典型的it组织&quot;&gt;一个典型的IT组织&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://oqk2bkk90.bkt.clouddn.com/14982071219886.jpg&quot; alt=&quot;一个典型的IT组织图&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;时间都去哪了&quot;&gt;时间都去哪了&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://oqk2bkk90.bkt.clouddn.com/14984417781058.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;生产团队有将近一半（47%）的时间花在了与部署有关的工作中：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;执行实际的部署工作，或&lt;/li&gt;
  &lt;li&gt;修复与部署工作有关的问题&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;基础架构自动化&quot;&gt;基础架构自动化&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://oqk2bkk90.bkt.clouddn.com/14982077583178.jpg&quot; alt=&quot;&quot; /&gt;
这些统计告诉我们：&lt;/p&gt;

&lt;p&gt;只需手工运行5条命令的情况下，成功部署的概率就已跌至86%。
如需手工运行55条命令，成功部署的概率将跌至22%。
如需手工运行100条命令，成功部署的概率将趋近于0（仅2%）！&lt;/p&gt;

&lt;h3 id=&quot;devops仅此一次一颗神奇的银弹&quot;&gt;DevOps：仅此一次，一颗神奇的银弹&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://oqk2bkk90.bkt.clouddn.com/14982079261283.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;DevOps主要通过扩展敏捷开发实践，通过构建，验证，部署和交付,来进一步简化软件更改的移动，同时赋予跨职能团队完全拥有软件应用程序 - 从设计到生产支持&lt;/li&gt;
  &lt;li&gt;DevOps鼓励软件开发者和IT运维人员之间所进行的沟通、协作、集成和自动化，借此有助于改善双方在交付软件过程中的速度和质量。&lt;/li&gt;
  &lt;li&gt;DevOps团队更侧重于通过标准化开发环境和自动化交付流程改善交付工作的可预测性、效率、安全性，以及可维护性。理想情况下，DevOps可以为开发者提供更可控的生产环境，帮助他们更好地理解生产基础架构。&lt;/li&gt;
  &lt;li&gt;DevOps鼓励团队自主进行自己应用程序的构建、验证、交付和支持。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;devops能给我们带来什么&quot;&gt;DevOps能给我们带来什么&lt;/h2&gt;

&lt;h3 id=&quot;可重复性与可靠性&quot;&gt;&lt;strong&gt;可重复性与可靠性&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;时至今日，构建生产用计算机只需要运行脚本或必要的puppet命令即可。通过恰当地使用Docker容器或Vagrant虚拟机，只需运行一条命令即可配置好包含操作系统层以及所需软件和配置的生产用计算机。当然，随着各种变更或软件开发、持续集成，并自动测试，这套构建脚本或机制也会进行持续集成。
最终幸亏有了XP或敏捷，我们在软件开发端所使用的同一套实践也能让运维端获益。&lt;/p&gt;

&lt;h3 id=&quot;生产力&quot;&gt;&lt;strong&gt;生产力&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;一键部署，一键供应，一键创建新环境……整个生产环境可以通过一条命令或一键点击的方式创建。这样的一条命令也许会运行长达数小时，但在这过程中运维人员可以从事其他更有趣的工作，而无需等待一条命令执行完毕后继续输入下一条命令，毕竟这样的过程有时候可能需要花费几天时间才能完成……&lt;/p&gt;

&lt;h3 id=&quot;恢复时间&quot;&gt;&lt;strong&gt;恢复时间&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;一键点击即可恢复生产环境，就是这么简单。&lt;/p&gt;

&lt;h3 id=&quot;确保基础架构的同质&quot;&gt;&lt;strong&gt;确保基础架构的同质&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;彻底避免运维人员每次构建环境或安装软件时最终获得的结果与预期有所差异，这是确保基础架构绝对同质,并且可再现的唯一可行方法。以此为基础，通过对脚本或Puppet配置文件使用版本控制机制，我们甚至可以重建出与上周、上个月，或软件特定版本发布时完全一致的生产环境。&lt;/p&gt;

&lt;h3 id=&quot;维持整齐划一的标准&quot;&gt;&lt;strong&gt;维持整齐划一的标准&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;基础架构标准甚至可以不复存在，代码本身就是标准。&lt;/p&gt;

&lt;h3 id=&quot;让开发者自行完成大部分工作&quot;&gt;&lt;strong&gt;让开发者自行完成大部分工作&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;如果开发者自己突然可以在自己的基础架构上一键点击重建生产环境，他们也就可以自行完成很多与生产环境有关的任务，例如更好地理解生产失败，提供更恰当的配置，实现部署脚本等。&lt;/p&gt;

&lt;p&gt;亚马逊CTOWerner Vogel甚至在2014年说过：&lt;/p&gt;

&lt;p&gt;“谁开发，谁运行。”&lt;/p&gt;

&lt;h3 id=&quot;发现浪费&quot;&gt;&lt;strong&gt;发现浪费&lt;/strong&gt;&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;一些不必要的多分支开发，合并后发生问题的风险高。多个项目中可能都要修改同一个模块的代码，每次在最后合并代码时都会出现一些问题，非常痛苦，尤其是修改比较大的时候，合并及修复时间较长。&lt;/li&gt;
  &lt;li&gt;推迟问题被发现的时间。每个开发人员会将需求分解成多个技术任务后开发。所以，所有任务完成之前，应用程序一直处于不可用状态。当最后在一起联调时，常常会发现一些意想不到的问题。&lt;/li&gt;
  &lt;li&gt;基于流程平台的沟通。在提测环节中，沟通完全基于内部项目管理平台和即时消息工具或Email。&lt;/li&gt;
  &lt;li&gt;常规的例行工作很难自动化。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;从上面这些内容，不难发现，流程中更倾向于将问题推迟到后面解决（比如最后集成联调），将工具（平台、邮件、即时通讯）作为协作的基础，而角色间的沟通几乎完全依赖于前一个环节的产物（比如MRD、产品代码、上线步骤）。我们可以使用哪些对策进行优化，达到消除浪费的目的呢？&lt;/p&gt;

&lt;h2 id=&quot;devops如何落地&quot;&gt;DevOps如何落地&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;纸上听来终觉浅,实践是检验真理的唯一标准.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;http://oqk2bkk90.bkt.clouddn.com/14982080278052.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;iac基础架构即代码&quot;&gt;IaC(基础架构即代码)&lt;/h3&gt;

&lt;p&gt;基础架构即代码（IaC）是大部分通用DevOps实践的前提要求，例如版本控制、代码审阅、持续集成、自动化测试。这一概念涉及计算基础架构（容器、虚拟机、物理机、软件安装等）的管理和供应，以及通过机器可处理的定义文件或脚本对其进行的配置，交互式配置工具和手工命令的使用已经不合时宜了。&lt;/p&gt;

&lt;p&gt;这一原则对DevOps的重要性怎么强调都不为过，它可以真正将软件开发相关的实践应用给服务器和基础架构。&lt;/p&gt;

&lt;h3 id=&quot;持续交付&quot;&gt;持续交付&lt;/h3&gt;
&lt;p&gt;持续交付是一种可以帮助团队以更短的周期交付软件的方法，该方法确保了团队可以在任何时间发布出可靠的软件。该方法意在以更快速度更高频率进行软件的构建、测试和发布。&lt;/p&gt;

&lt;p&gt;注意：持续交付 ≠ 持续部署&lt;/p&gt;

&lt;p&gt;持续交付的主要想法在于：&lt;/p&gt;

&lt;p&gt;部署越频繁，对部署流程就会越熟悉，自动化机制就能获得更好的结果。
部署越频繁，所部属的变更集就越微不足道，而这些内容最有可能出错。
部署越频繁，TTR（修复／解决所需时间）指标就会越出色，从业务用户处获得有关功能的各类反馈的速度越快&lt;/p&gt;

&lt;p&gt;但持续交付并不仅仅是尽可能频繁地构建可发布、生产就绪版本的软件产品那么简单。持续交付包含3个关键实践：&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;从实践中学习&lt;/li&gt;
  &lt;li&gt;自动化&lt;/li&gt;
  &lt;li&gt;更频繁的部署&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;从实践中学习&lt;/p&gt;

    &lt;p&gt;痴迷于度量,我们应该度量一切！&lt;/p&gt;

    &lt;p&gt;不需要“考虑”，只需要“知道”！“知道”的唯一方法就是度量，度量一切：响应时间、用户思考时间、展示次数、API调用次数、点击率等，但这些并非需要度量的全部。找出所有能让你更进一步了解用户对功能看法的度量指标，对所有这些指标进行度量！&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;自动化
    &lt;blockquote&gt;
      &lt;p&gt;这里想强调的是，在没有将与基础架构有关的所有供应和任务实现妥善、全面的自动化之前，持续交付根本无从谈起。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;更频繁的部署&lt;/p&gt;

    &lt;p&gt;DevOps的信条在于：“越是困难的事，需要更频繁地进行！”
 自动化测试、重构、数据库迁移、面向客户的产品规格、规划、发布 - 所有这些活动都要尽可能频繁地进行。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;那么这就产生了一个问题：使用DevOps方法时，该选择怎样的交付频率？&lt;/p&gt;

&lt;p&gt;最佳理论值应该是：如果不能实现&lt;strong&gt;至少每两周一次交付&lt;/strong&gt;，或在冲刺阶段结束时交付，那么连敏捷都谈不上，DevOps又从何谈起呢？&lt;/p&gt;

&lt;h3 id=&quot;持续交付的前提需求&quot;&gt;持续交付的前提需求&lt;/h3&gt;
&lt;p&gt;在改为使用持续交付方式之前，需要满足如下需求：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;对软件组件的开发和平台的供应和设置进行持续集成。&lt;/li&gt;
  &lt;li&gt;TDD - 测试驱动的开发。&lt;/li&gt;
  &lt;li&gt;代码审阅！至少要进行代码审阅……如果能进行结对编程（Pair programming）当然就更好了。&lt;/li&gt;
  &lt;li&gt;软件的持续审计 - 例如使用Sonar。&lt;/li&gt;
  &lt;li&gt;在生产级环境实现功能测试的自动化。&lt;/li&gt;
  &lt;li&gt;更强大的非功能测试自动化（性能、可用性等）。&lt;/li&gt;
  &lt;li&gt;独立于目标环境的自动化打包和部署。&lt;/li&gt;
  &lt;li&gt;另外在管理重大功能和演进时，还需要具备健全的软件开发实践，例如零停机部署技术。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;零停机部署&quot;&gt;零停机部署&lt;/h3&gt;

&lt;p&gt;“零停机部署（ZDD）可在不中断现有服务的情况下部署新版系统。”&lt;/p&gt;

&lt;p&gt;下文简单介绍4种技术：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;功能开关（Feature Flipping）&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;滚动部署（Dark launch）&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;蓝／绿部署（Blue/Green Deployment）&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;金丝雀发布（Canari release）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;团队协作&quot;&gt;团队协作&lt;/h3&gt;
&lt;p&gt;敏捷软件开发破除了需求分析、测试和开发之间的一些隔阂。部署、运维和维护等其他活动与软件开发过程中的其他环节也存在类似的分隔。DevOps方法意在破除所有这些隔阂，鼓励开发和运维人员之间的协作。&lt;/p&gt;

&lt;p&gt;如果没有培养出正确的文化，就算有最棒的工具，DevOps对你而言也不过是另一个热门词汇罢了。&lt;/p&gt;

&lt;p&gt;DevOps文化的主要特征在于开发和运维角色之间日益增加的协作。这是一种在团队内部以及组织层面上很重要的文化变迁，通过这样的变迁才能促进更好的协作。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://oqk2bkk90.bkt.clouddn.com/14982096057176.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;团队合作对DevOps是如此的重要，大部分方法论所要实现的最终目标总的来说可以通过两个C来实现：&lt;strong&gt;协作（Collaboration）&lt;/strong&gt;和&lt;strong&gt;沟通（Communication）&lt;/strong&gt;。虽然单纯做到这些距离真正的DevOps工作环境还有很大的差距，但任何公司只要能坚持这两个C，就等于迈出了最正确的第一步。&lt;/p&gt;

&lt;h3 id=&quot;devops落地障碍&quot;&gt;DevOps落地障碍&lt;/h3&gt;

&lt;h4 id=&quot;混乱之墙&quot;&gt;混乱之墙&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://oqk2bkk90.bkt.clouddn.com/14982097271016.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在传统开发周期中，开发团队将新发布的软件“隔墙扔给”运维人员，意味着自己的工作已经顺利完成。&lt;/p&gt;

&lt;p&gt;运维人员接手开发者的成果，准备开始进行部署。运维人员手工修改由开发者提供的部署脚本，当然更多时候这些脚本都是运维人员自己维护的。&lt;/p&gt;

&lt;p&gt;运维人员还需要手工修改配置文件，以反映生产环境的需求，而生产环境往往与开发或QA环境有很大差异。&lt;/p&gt;

&lt;p&gt;就算最理想的情况，运维人员可能只是做了一些在上一个环境中已经做过的重复工作，而最糟糕的情况，可能会引入或发现新的Bug。&lt;/p&gt;

&lt;p&gt;随后IT运维团队开始讨论他们所认为的，目前最正确的部署流程，然而由于开发和运维在脚本、配置、流程，甚至环境等方面的差异，基本上等同于要从零开始将所有工作重新执行一遍。&lt;/p&gt;

&lt;p&gt;当然这一过程中不可避免会遇到问题，他们联系开发者希望进行排错。运维称开发者提供的代码本身有问题，开发者则回应称代码在自己的环境中一切正常，因此错误肯定源自运维端。&lt;/p&gt;

&lt;p&gt;由于配置、文件位置，以及面临这种状态所执行的操作与自己的预期等因素存在较大差异，开发者甚至很难对这样的问题进行诊断。变更窗口留下的时间所剩无几，当然也没什么足够靠谱的方法将环境回滚至上一个正常状态。&lt;/p&gt;

&lt;p&gt;那么原本应该一帆风顺的部署过程，为什么最后却变成了“众志成城”的应急演习？必须经历大量指责和错误才能最终让生产环境恢复可用状态？&lt;/p&gt;

&lt;p&gt;这种情况经常发生，经常！&lt;/p&gt;

&lt;h4 id=&quot;软件开发流程&quot;&gt;软件开发流程&lt;/h4&gt;
&lt;p&gt;下图简要描述了敏捷软件开发流程通常的样子。
&lt;img src=&quot;http://oqk2bkk90.bkt.clouddn.com/14982100328183.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最开始，业务代表与产品负责人以及架构团队合作定义软件，这一过程可能会使用Story Mapping和用户故事，或者使用更完整的规范。&lt;/p&gt;

&lt;p&gt;随后开发团队通过短暂的开发冲刺开发出软件，并在每个冲刺结束后将生产就绪版本的软件发布给业务用户，进而收集反馈并尽可能频繁地调整方向。&lt;/p&gt;

&lt;p&gt;最后，经历过每个新的里程碑后，将软件部署给整个业务线更广泛的用户群体。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://oqk2bkk90.bkt.clouddn.com/14982100440048.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;DevOps造成的最大挑战在于需要理解运维人员是软件的另一个用户群体！因此他们也应该被全面纳入软件开发流程中。&lt;/p&gt;

&lt;p&gt;在预定的时间里，运维应该给出自己的非功能需求，就如同业务用户给出自己的功能需求一样。开发团队应该按照同等程度的重要性和优先级处理这种非功能需求。&lt;/p&gt;

&lt;p&gt;在实现的过程中，运维应该持续提供反馈和非功能测试规范，就像业务用户针对功能特性提供反馈一样。&lt;/p&gt;

&lt;p&gt;最后，运维和业务用户一样，成为了软件的用户。&lt;/p&gt;

&lt;h4 id=&quot;共享工具&quot;&gt;共享工具&lt;/h4&gt;
&lt;p&gt;在传统的大型企业中，运维团队和开发团队分别使用专用的，没有什么交集的工具集。&lt;/p&gt;

&lt;p&gt;运维人员通常并不想了解开发团队所使用的SCM系统以及持续集成环境。他们认为这些并非自己的本职工作，害怕自己在触及这些系统后会被开发者的各种请求所淹没。毕竟他们为了照料生产系统就有忙不完的工作了。&lt;/p&gt;

&lt;p&gt;另一方面，开发者通常无法访问生产系统的日志和监视日志，有时这是因为没有这样的意愿，有时则是因为制度或安全方面的顾虑。&lt;/p&gt;

&lt;p&gt;这种状况需要改变！DevOps应运而生。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://oqk2bkk90.bkt.clouddn.com/14982101389443.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;协同工作&quot;&gt;协同工作&lt;/h4&gt;
&lt;p&gt;DevOps的一种基本哲学是认为，开发者和运维人员必须定期进行密切的合作。&lt;/p&gt;

&lt;p&gt;这就意味着他们必须将对方视作重要的利益相关者，并积极主动地寻求合作。&lt;/p&gt;

&lt;p&gt;受到XP实践中“现场客户”的启发，敏捷开发者受此激励可以与业务进行更紧密的合作，自律的敏捷者还可以更进一步将这样的实践运用给更广泛的利益相关者，例如可以让开发者与所有其他相关者进行合作，包括运维和支持人员。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://oqk2bkk90.bkt.clouddn.com/14982102319749.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;此外还可以通过协作：&lt;/p&gt;

&lt;p&gt;让运维人员参与敏捷仪式（每日Scrum、冲刺规划、再次冲刺等）
让开发者参与生产环境的推出任务
在开发和运维之间打造统一的持续改进目标&lt;/p&gt;

&lt;h2 id=&quot;devops工具链&quot;&gt;DevOps工具链&lt;/h2&gt;

&lt;h3 id=&quot;devops工具概述&quot;&gt;DevOps工具概述&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;DevOps实际是一种文化上的变迁，代表了开发、运维、测试等环节之间的协作，因此DevOps工具是非常多种多样的，甚至可以由多种工具组成一个完整的DevOps工具链。此类工具可以应用于一种或多种类别，并可体现出软件开发和交付过程的不同阶段：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;编码：代码开发和审阅，版本控制工具、代码合并工具&lt;/li&gt;
  &lt;li&gt;构建：持续集成工具、构建状态统计工具&lt;/li&gt;
  &lt;li&gt;测试：通过测试和结果确定绩效的工具&lt;/li&gt;
  &lt;li&gt;打包：成品仓库、应用程序部署前暂存&lt;/li&gt;
  &lt;li&gt;发布：变更管理、发布审批、发布自动化&lt;/li&gt;
  &lt;li&gt;配置：基础架构配置和部署，基础架构即代码工具&lt;/li&gt;
  &lt;li&gt;监视：应用程序性能监视、最终用户体验&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;虽然可用工具有很多，但其中一些环节是组织内部应用DevOps工具链不可或缺的。
诸如Docker（容器化）、Jenkins（持续集成）、Puppet（基础架构构建）、Vagrant（虚拟化平台）等常用、广泛使用的工具都是2016年的DevOps热门工具。&lt;/p&gt;

&lt;p&gt;基础架构组件的版本控制、持续集成和自动化测试&lt;/p&gt;

&lt;p&gt;基础架构的版本控制能力（而非基础架构的构建脚本或配置文件）及对其进行自动化测试的能力极其重要。
此外基础架构元素应该能向软件交付物一样进行持续集成&lt;/p&gt;

&lt;h3 id=&quot;devops工具清单&quot;&gt;DevOps工具清单&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://oqk2bkk90.bkt.clouddn.com/14869758651397.jpg&quot; alt=&quot;企业的软件交付价值流动&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;代码管理（SCM）：GitHub、GitLab、BitBucket、SubVersion、TFS&lt;/li&gt;
  &lt;li&gt;构建工具：Ant、Gradle、maven&lt;/li&gt;
  &lt;li&gt;自动部署：Capistrano、CodeDeploy&lt;/li&gt;
  &lt;li&gt;持续集成（CI）：Bamboo、Hudson、Jenkins&lt;/li&gt;
  &lt;li&gt;配置管理：Ansible、Chef、Puppet、SaltStack、ScriptRock GuardRail&lt;/li&gt;
  &lt;li&gt;容器：Docker、LXC、Rkt、第三方厂商如AWS&lt;/li&gt;
  &lt;li&gt;编排：Kubernetes、Apache Mesos、DC/OS、Rancher&lt;/li&gt;
  &lt;li&gt;服务注册与发现：Zookeeper、etcd、Consul&lt;/li&gt;
  &lt;li&gt;脚本语言：python、ruby、shell&lt;/li&gt;
  &lt;li&gt;日志管理：ELK、Logentries&lt;/li&gt;
  &lt;li&gt;系统监控：Datadog、Graphite、Icinga、Nagios&lt;/li&gt;
  &lt;li&gt;性能监控：AppDynamics、New Relic、Splunk&lt;/li&gt;
  &lt;li&gt;压力测试：JMeter、Blaze Meter、loader.io&lt;/li&gt;
  &lt;li&gt;预警：PagerDuty、pingdom、厂商自带如AWS SNS&lt;/li&gt;
  &lt;li&gt;HTTP加速器：Varnish&lt;/li&gt;
  &lt;li&gt;消息总线：ActiveMQ、SQS&lt;/li&gt;
  &lt;li&gt;应用服务器：Tomcat、JBoss&lt;/li&gt;
  &lt;li&gt;Web服务器：Apache、Nginx、IIS&lt;/li&gt;
  &lt;li&gt;数据库：MySQL、Oracle、PostgreSQL等关系型数据库；cassandra、mongoDB、redis等NoSQL数据库&lt;/li&gt;
  &lt;li&gt;项目管理（PM）：Jira、Asana、Taiga、Trello、Basecamp、Pivotal Tracker&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://oqk2bkk90.bkt.clouddn.com/14869759221117.jpg&quot; alt=&quot;持续交付流水线下的团队协作&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;DevOps是一次革命，主要是为了消除拥有大规模IT部门的大型企业中，开发团队和运维团队之间由于历史原因产生的隔阂与孤立所造成的混乱现状。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在笔者15年的职业生涯中，2/3的时间就职于此类大行机构，其中大部分是金融机构，每天笔者都在见证者这堵混乱之墙的存在。例如笔者经常会听到这样的说法：&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;在笔者的Tomcat上工作很正常，很抱歉，但笔者完全不懂你所用的Websphere，帮不上你了。”（开发者说）
“我们真的不能从生产数据库中给你提取这张表，里面包含了与客户有关的机密数据。”（运维人员说）
每天都会遇到其他很多类似的对话……天天如此！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;那么对于那些小规模的，开发和运维职能之间通常不会产生那么大分歧的企业呢？
这样的企业应用DevOps原则和实践，例如自动化部署、持续交付和功能开关，一样能获益匪浅。&lt;/p&gt;

&lt;p&gt;DevOps原则可以总结为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://oqk2bkk90.bkt.clouddn.com/14982105396780.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.infoq.com/cn/articles/detail-analysis-of-devops#&quot;&gt;http://www.infoq.com/cn/articles/detail-analysis-of-devops#&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.profitbricks.com/51-best-devops-tools-for-devops-engineers/&quot;&gt;https://blog.profitbricks.com/51-best-devops-tools-for-devops-engineers/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.niceideas.ch/roller2/badtrash/entry/devops-explained&quot;&gt;https://www.niceideas.ch/roller2/badtrash/entry/devops-explained&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;thanks&quot;&gt;Thanks!&lt;/h2&gt;

</description>
        <pubDate>Wed, 28 Jun 2017 00:00:00 +0800</pubDate>
      </item>
    
  </channel>
</rss>